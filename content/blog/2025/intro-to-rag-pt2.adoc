---
date: 2025-04-25T09:00:00-06:00
featured_image: "/img/intro-to-rag/???.jpg"
image_credit: https://unsplash.com/photos/orange-pink-and-teal-illustration-Tk0B3Dfkf_4?utm_content=creditShareLink&utm_medium=referral&utm_source=unsplash
tags: ["rag","vector","llm","learning","genai"]
title: "Intro to RAG: Foundations of Retrieval Augmented Generation, part 2"
draft: true
omit_header_text: true
---

{{< image-credit >}}

//blah blah blah

== Vector RAG, GraphRAG, and agents

I've recently started thinking of GenAI in layers - the LLM, semantic search, retrieval queries, agents, etc. Each of these layers can add different kinds of value to the solution, producing custom, potentially high-quality results and reducing the risk of hallucinations.

The comparison I like is to layered foods. Additional layers can bring more flavors, textures, and overall improve a food, but at some point, too many layers overwhelm the palate or make it hard to eat.

image::/img/intro-to-rag/layered-dessert.jpg[Layers can improve food, as well as AI, 250]

However, additional layers also add complexity, so analysis needs to be done to evaluate whether the added complexities for each component are worth the hassle for the use case. If the costs are worth the benefits, take them on with confidence. If not, perhaps there is a simpler approach to improve results without the added complexity of AI.

Let's look at some of the layers in the current GenAI landscape.

=== Vector RAG

Vector-only RAG (also called "Naive RAG") means that you create vectors (embeddings) for the data you want to provide to the LLM and search that data using vector similarity search. This approach is very powerful, as it retrieves semantically relevant information from a large dataset, allowing the LLM to generate more accurate and contextually appropriate responses.

image::/img/intro-to-rag/vector-data.png[Data in a vector database]

Many databases (including graph, relational, document, etc) incorporated vector embedding support for semantic searches onto their specialized models, though they may not be as performant as native vector databases for certain workloads.

Vector databases are designed and optimized for storing and searching vector embeddings, not for storing a lot of metadata or related entities. Plus, similar might not always be the same as relevant.

This is where a graph layer can provide additional context and relationships between the data points, improving the relevance of the retrieved information. This is especially important when dealing with complex analysis or when the data has intricate relationships that should be considered.

=== Graph RAG

https://neo4j.com/blog/genai/what-is-graphrag/[GraphRAG^] introduces a layer that utilizes relationships between data points, enhancing the retrieval process by considering the connections and context in the data. GraphRAG combines the strengths of vector similarity search with the connected data of graph databases, allowing for more nuanced and related context retrieval.

image::/img/intro-to-rag/graph-data.png[Data in a graph database]

Just as with vector RAG, graph RAG runs a similarity search to find the most relevant data points. A retrieval query then pulls relationships around those points, allowing for a more comprehensive understanding of the context and meaning behind the data.

Because graph databases are designed to store and query complex relationships, they are particularly useful in scenarios where the relationships between data points are critical for understanding the context or meaning of the information. If you think about generic or broad questions, giving an LLM access to a knowledge graph can help narrow its probabilities using context within particular industry information or lesser-known research topics.

GraphRAG has been shown to improve the accuracy and relevance of generated outputs, especially in complex domains. But even a knowledge graph might not be able to include all relevant information.

This is where agents come into play, which act as intermediaries carrying out tasks and retrieving information from various sources. Agents can be designed to break down complex processes into a series of steps and complete them to gather the most relevant information for a given query.

=== AI Agents

https://www.anthropic.com/engineering/building-effective-agents[AI Agents^] can range from simple to complex and can be arranged in configurations of one or multiple agents, depending on their design and functionality. Agentic systems can be designed to interact with various data sources, APIs, and even other AI systems to gather information, automate tasks, and generate outputs. Agents contribute to improved automation, but also work towards autonomous systems that can make decisions and operate independently.

image::/img/intro-to-rag/agentic-system.png[Agentic system design, 500]

Agents are a powerful tool for enhancing GenAI systems, but they also add complexity. Developers need to understand defining and coordinating multiple tools for agents to access, agentic memory, and guardrails to ensure that the agents are working together effectively and safely. This is especially important in scenarios where the agents are interacting with sensitive data or making decisions that could have significant consequences.

Design of agentic systems can vary widely, from simple rule-based systems to complex multi-agent systems that can learn and adapt over time. The choice of design will depend on the specific use case and the level of complexity required.

== What should you choose?

So how do you choose which layer(s) to use? It depends on the use case and the complexity of the data. There are many variations and nuances to consider, and the best decision will likely require testing several different combinations of LLM models, vector stores (databases), and agentic architectures to find the optimal solution for your specific needs.

Does vector similarity search provide a high enough accuracy and relevance for your use case? If so, then you may not need to add the complexity of a graph database or agentic system. If results are missing context or high accuracy is critical, then a graph database approach may be the best option. Are there simply too many scattered and inconsistent data sources to make a unified data store practical or will requests contain tasks/data that need to be sent to other systems? Then an agentic system may be worth the added complexity.

== Wrapping up!

In this blog post, we explored the foundations of Retrieval Augmented Generation (RAG) and how it enhances the capabilities of Large Language Models (LLMs) by integrating them with external knowledge sources. We discussed the importance of vector embeddings, similarity search, and the different layers of RAG, including vector RAG, graph RAG, and agents.

By understanding these concepts, you can make informed decisions about how to leverage RAG in your own projects and applications. As the field of Generative AI continues to evolve, staying up-to-date with these foundational concepts will be crucial for harnessing the full potential of AI technologies.

Whether you're a developer, data scientist, or simply someone interested in the future of AI, understanding RAG and its components will empower you to create more effective and reliable AI systems.

Happy coding!

== Resources

* Tutorial: https://www.mathsisfun.com/algebra/vectors.html[Vectors - Math is Fun^]
* Blog post: https://towardsdatascience.com/explaining-vector-databases-in-3-levels-of-difficulty-fc392e48ab78[Explaining Vector Databases in 3 Levels of Difficulty - Towards Data Science^]
* Blog post: https://frankzliu.com/blog/a-gentle-introduction-to-vector-databases[Vector Databases - Frank Liu^]
* Blog post: https://neo4j.com/blog/genai/what-is-graphrag/[What is GraphRAG? - Neo4j^]