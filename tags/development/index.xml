<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>development on Jennifer Reif</title><link>https://jmhreif.com/tags/development/</link><description>Recent content in development on Jennifer Reif</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Thu, 14 Jul 2022 09:00:00 -0600</lastBuildDate><atom:link href="https://jmhreif.com/tags/development/index.xml" rel="self" type="application/rss+xml"/><item><title>Journeys in Java, Level 7: Externalize Microservice Configuration</title><link>https://jmhreif.com/blog/microservices-level7/</link><pubDate>Thu, 14 Jul 2022 09:00:00 -0600</pubDate><guid>https://jmhreif.com/blog/microservices-level7/</guid><description>Photo credit Our decided next step for this project takes us in a new direction by adding externalized configuration for our applications. We already saw how to do something similar with MongoDB database credentials in Docker Compose to access a local database container, but what do we do when the database is hosted on public cloud or contains sensitive data? We probably don’t want to publish our credentials anywhere or even prevent accidental publishing.</description></item><item><title>Journeys in Java, Level 6: Build a Microservice with Neo4j</title><link>https://jmhreif.com/blog/microservices-level6/</link><pubDate>Tue, 21 Jun 2022 09:00:00 -0600</pubDate><guid>https://jmhreif.com/blog/microservices-level6/</guid><description>Photo credit For our next adventure in Java microservices, we want to expand our system for book review data. While books and authors are well-suited for a document database such as MongoDB, once you add reviews to the mix, the importance of the relationships makes this project better suited for a graph database. This way, we can utilize relationships between the different entities to improve analysis based on the structure of the connections.</description></item><item><title>Journeys in Java, Level 5: Manage Microservices with Docker Compose</title><link>https://jmhreif.com/blog/microservices-level5/</link><pubDate>Thu, 21 Apr 2022 09:00:00 -0600</pubDate><guid>https://jmhreif.com/blog/microservices-level5/</guid><description>Photo credit We continue building our microservices system by adding a coordination layer to handle spinning multiple services up and down. In previous blog posts, we grew from two Spring Boot applications to three applications + a database container. As we continue to scale and broaden our system, we will need something to coordinate service and ensure consistent communication (avoid human error).
We will do this through docker-compose, an orchestration tool that manages containerized applications.</description></item><item><title>Journeys in Java, Level 4: Building an Empire of Microservices</title><link>https://jmhreif.com/blog/microservices-level4/</link><pubDate>Thu, 31 Mar 2022 09:00:00 -0600</pubDate><guid>https://jmhreif.com/blog/microservices-level4/</guid><description>Photo credit This blog post is the fourth iteration in a series of posts about building microservices in Java. The initial post started with a single string message passed between two locally-running applications, and we are gradually adding services and functionality along the way.
In this level 4 installment, we will add a new service that will manage book authors. It will call a database containing a data domain of books and retrieve authors and their information.</description></item><item><title>Journeys in Java, Level 3: Building an Empire of Microservices</title><link>https://jmhreif.com/blog/microservices-level3/</link><pubDate>Fri, 11 Feb 2022 09:00:00 -0600</pubDate><guid>https://jmhreif.com/blog/microservices-level3/</guid><description>Photo credit We are still in the beginning stages of building microservices with Java, but we have already seen how to send and receive communications between two Spring Boot applications. In the first blog post of this series, our two applications transmitted a message string of &amp;#34;Hello, World!&amp;#34;. In the second blog post, we took it one step further by embedding a MongoDB database into our service1, added a data domain (books) with four pre-populated entries, and transmitted the Book information between the two applications.</description></item><item><title>Journeys in Java, Level 2: Building an Empire of Microservices</title><link>https://jmhreif.com/blog/microservices-level2/</link><pubDate>Thu, 27 Jan 2022 09:00:00 -0600</pubDate><guid>https://jmhreif.com/blog/microservices-level2/</guid><description>Photo credit In my last blog post, we began building microservices in Java with two Spring Boot applications, passing a &amp;#34;Hello, World!&amp;#34; string from one application to the other. We focused on reduced complexity, minimum previous knowledge, and few components. Next, we can slowly add pieces that simulate microservices projects in the real world.
One way to do this is by adding a data domain. Applications often model some scenario in the real world such as maintaining office building temperatures, finding connected devices on a network, or recommending a tv show.</description></item><item><title>Journeys in Java, Level 1: Building an Empire of Microservices</title><link>https://jmhreif.com/blog/microservices-level1/</link><pubDate>Tue, 21 Dec 2021 09:00:00 -0600</pubDate><guid>https://jmhreif.com/blog/microservices-level1/</guid><description>Photo credit Microservices have been used and deployed in businesses and projects for awhile, and there is plenty of content available for architecting them into a system. For my next project, I want to dive into the world of microservices and begin building my own little virtual empire from different kinds of services to find out the complexities, best practices, power, and trouble that comes with them. I will share all my learnings along the way, as well.</description></item><item><title>Winter to Spring: Migrating from Spring Data Neo4j 5 to 6, Part 3</title><link>https://jmhreif.com/blog/migrate-sdn-part3/</link><pubDate>Wed, 22 Sep 2021 09:00:00 -0600</pubDate><guid>https://jmhreif.com/blog/migrate-sdn-part3/</guid><description>Photo credit You may have heard quite a bit of buzz around reactive programming or reactive principles in recent months or years. Some people say it is the future, while others prefer their existing monoliths. So what is all the fuss actually about? What is reactive? Is it beneficial?
As with all things in life, it depends. :) Remember, that technical decisions are often large investments of time - resources to create it and/or maintain for lengths of time.</description></item><item><title>Winter to Spring: Migrating from Spring Data Neo4j 5 to 6, Part 2</title><link>https://jmhreif.com/blog/migrate-sdn-part2/</link><pubDate>Thu, 09 Sep 2021 09:00:00 -0600</pubDate><guid>https://jmhreif.com/blog/migrate-sdn-part2/</guid><description>Photo credit Our previous post (Part 1) on this topic introduced us to Spring Data Neo4j and showed the architectural differences between version 5 and the latest version 6. This post begins the migration process by taking a Spring Data Neo4j 5 application with OGM and upgrades to the dependencies and syntax changes of Spring Data Neo4j 6.
Without further ado, let’s dive in!
Current application overview The code for today’s migration is a specific branch in the migration Github repository.</description></item><item><title>Winter to Spring: Migrating from Spring Data Neo4j 5 to 6, Part 1</title><link>https://jmhreif.com/blog/migrate-sdn-part1/</link><pubDate>Thu, 12 Aug 2021 09:00:00 -0600</pubDate><guid>https://jmhreif.com/blog/migrate-sdn-part1/</guid><description>Photo credit A major upgrade to Spring Data Neo4j was released at the end of last year as part of the Spring Data release train. If you were involved in Spring Data and Neo4j news before that, you may have seen hints of this coming with the SDN/RX library entering the scene in late 2019. The library brought with it a lighter footprint, as well as a more straightforward implementation of features to reduce confusion and errors (therefore also improving efficiency) in development and production.</description></item><item><title>Create a Data Marvel with Spring Data Neo4j</title><link>https://jmhreif.com/blog/create-data-marvel-sdn/</link><pubDate>Mon, 02 Aug 2021 12:00:00 -0600</pubDate><guid>https://jmhreif.com/blog/create-data-marvel-sdn/</guid><description>Photo credit I have had a couple of Github projects demonstrating bits of functionality for Spring Data Neo4j, but they had last been updated in 2020 when the new Spring Data Neo4j 6 was still a beta version known as SDN/RX. Since there have been several changes since then, I thought I would give the projects a refresh and make them current.
Project code:
SDN Marvel (imperative)</description></item></channel></rss>