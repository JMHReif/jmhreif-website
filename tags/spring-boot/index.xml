<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>spring-boot on Jennifer Reif</title><link>https://jmhreif.com/tags/spring-boot/</link><description>Recent content in spring-boot on Jennifer Reif</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Thu, 31 Mar 2022 09:00:00 -0600</lastBuildDate><atom:link href="https://jmhreif.com/tags/spring-boot/index.xml" rel="self" type="application/rss+xml"/><item><title>Journeys in Java, Level 4: Building an Empire of Microservices</title><link>https://jmhreif.com/blog/microservices-level4/</link><pubDate>Thu, 31 Mar 2022 09:00:00 -0600</pubDate><guid>https://jmhreif.com/blog/microservices-level4/</guid><description>Photo credit This blog post is the fourth iteration in a series of posts about building microservices in Java. The initial post started with a single string message passed between two locally-running applications, and we are gradually adding services and functionality along the way.
In this level 4 installment, we will add a new service that will manage book authors. It will call a database containing a data domain of books and retrieve authors and their information.</description></item><item><title>Journeys in Java, Level 3: Building an Empire of Microservices</title><link>https://jmhreif.com/blog/microservices-level3/</link><pubDate>Fri, 11 Feb 2022 09:00:00 -0600</pubDate><guid>https://jmhreif.com/blog/microservices-level3/</guid><description>Photo credit We are still in the beginning stages of building microservices with Java, but we have already seen how to send and receive communications between two Spring Boot applications. In the first blog post of this series, our two applications transmitted a message string of &amp;#34;Hello, World!&amp;#34;. In the second blog post, we took it one step further by embedding a MongoDB database into our service1, added a data domain (books) with four pre-populated entries, and transmitted the Book information between the two applications.</description></item><item><title>Journeys in Java, Level 2: Building an Empire of Microservices</title><link>https://jmhreif.com/blog/microservices-level2/</link><pubDate>Thu, 27 Jan 2022 09:00:00 -0600</pubDate><guid>https://jmhreif.com/blog/microservices-level2/</guid><description>Photo credit In my last blog post, we began building microservices in Java with two Spring Boot applications, passing a &amp;#34;Hello, World!&amp;#34; string from one application to the other. We focused on reduced complexity, minimum previous knowledge, and few components. Next, we can slowly add pieces that simulate microservices projects in the real world.
One way to do this is by adding a data domain. Applications often model some scenario in the real world such as maintaining office building temperatures, finding connected devices on a network, or recommending a tv show.</description></item><item><title>Journeys in Java, Level 1: Building an Empire of Microservices</title><link>https://jmhreif.com/blog/microservices-level1/</link><pubDate>Tue, 21 Dec 2021 09:00:00 -0600</pubDate><guid>https://jmhreif.com/blog/microservices-level1/</guid><description>Photo credit Microservices have been used and deployed in businesses and projects for awhile, and there is plenty of content available for architecting them into a system. For my next project, I want to dive into the world of microservices and begin building my own little virtual empire from different kinds of services to find out the complexities, best practices, power, and trouble that comes with them. I will share all my learnings along the way, as well.</description></item></channel></rss>